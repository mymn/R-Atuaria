calendr="2022/06/01"
as.Date(calendr, "%y/%m/%d")
View(calendr)

#ano/mes/dia
Tocalendar=function(calendr){ #tranformar data juliana em data(dd/mm/aaaa)
  calendr=as.Date(calendr, origin="1900/01/01")
}

#ano/mes/dia
Tojulian=function(calendr){ #transformar data em data juliana
  calendr=julian.Date(calendr,origin=as.Date("1900-01-01"))
}


#criacao do vetor de fluxos
nfluxos=5 #numero de fluxos
fluxo=matrix(nrow=nfluxos,ncol=2)#[tempo,valor]tempo em data juliana
colnames(fluxo) <- c("Vencimento data juliana", "Valor")

#criacao do vetor de vertices
nvertices=5 #numero de vertices
vertices=matrix(nrow=nvertices,ncol=2) #[tempo,valor]
colnames(vertices) <- c("Data juliana", "Valor")

#vetor teste para fluxo
fluxo[,1]=c(44500,44100,3000,46000,45500)
fluxo[,2]=c(1,2,3,4,5)

#preencher os vertices
vertices[,1]=c(44710,45075,45440,45805,46170) #inserir as datas
vertices[,2]=0

#funcao para alocar os valores dos fluxos nos vertices
#compara a primeira coluna com as datas e aloca os valores da segunda
#coluna com os valores
#necessario converter em data juliana todos periodos
fluxovertice=function(nfluxos,fluxo){
  for(i in 1:nfluxos){
    dist0=which.min(abs(vertices[,1]-fluxo[i,1]))
    vertices[dist0,2]=vertices[dist0,2]+fluxo[i,2]}
  }
}


if (dist0>1||dist0<nvertices)
  dist1=abs((vertices[dist0+1,2]-vertices[dist0,2]
  dist2=abs((vertices[dist0-1,2]-vertices[dist0,2]
#ajustar para distribuir baseado na diferenca da distancia
if (dist1>dist2){
  vertices[dist0,2]=vertices[dist0,2]+fluxo[i,2]*dist2/dist0
  vertices[dist0-1,2]=vertices[dist0,2]+fluxo[i,2]*(dist0-dist2)/dist0
}
else if(dist2>dist1){
  vertices[dist0,2]=vertices[dist0,2]+fluxo[i,2]*dist1/dist0
  vertices[dist0+1,2]=vertices[dist0,2]+fluxo[i,2]*(dist0-dist1)/dist0
}

beta1
beta2
beta3
curva=beta1+beta2*((1-exp(-tau/lambda))/(tau/lambda))+beta3*(((1-exp(-tau/lambda))/(tau/lambda))-exp(-tau/lambda))

if(dist0==0){
#else if()
  
#Nelson-Siegel
#library(YieldCurve)
#Nelson.Siegel(rate=juros,maturity) #maturity em meses

  
